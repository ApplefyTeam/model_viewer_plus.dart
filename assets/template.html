<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
    body,
    model-viewer {
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
    }
</style>
<script type="module" src="model-viewer.min.js" defer></script>
<!-- body -->

<script>
  let canvasTexture = null;
  let originalTexture = null; // Variable to store the original texture
  let modelViewer = null;

  function getCanvasTexture() {
    if (canvasTexture) return canvasTexture;
    console.log("Creating new canvas texture");
    canvasTexture = modelViewer.createCanvasTexture();
    updateCanvasTexture();
    return canvasTexture;
  }

  function updateCanvasTexture1(
    customText,
    color,
    backgroundColor,
    fontSize,
    textX,
    textY,
    texture
  ) {
    console.log("Updating canvas texture 1");
    console.log("Received parameters:", {
      customText, color, backgroundColor, fontSize, textX, textY
    });

    const canvas = canvasTexture ? canvasTexture.source.element : document.createElement('canvas');
    const ctx = canvas.getContext('2d');

    if (backgroundColor) {
      ctx.fillStyle = backgroundColor;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    // Only proceed with text rendering if customText is provided
    if (customText != null) {
      // Set the text properties
      ctx.font = `${fontSize || 24}px Arial, sans-serif`;  // Default font size to 24 if null
      ctx.fillStyle = color || '#000000';  // Default color to black if null
      ctx.textBaseline = 'middle';
      ctx.textAlign = 'center';

      // Calculate text position
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      console.log("setting custom text: " + customText);

      // Apply text, defaulting offsets to 0 if null
      ctx.fillText(customText, centerX + (textX || 0), centerY + (textY || 0));
    }

    if (texture) updateTexture(texture);

    if (canvasTexture) {
      console.log("Updating canvas texture source 1");
      canvasTexture.source.update();
    }
  }

  function updateTexture(texture) {
    const material = modelViewer.model.materials[0];
    const { baseColorTexture } = material.pbrMetallicRoughness;

    // Store the original texture
    if (originalTexture === null) {
      console.log("keep original texture");
      originalTexture = baseColorTexture;
    }

    console.log("Texture type changed to:", texture);
    switch (texture) {
      case "none":
        baseColorTexture.setTexture(originalTexture);
        break;
      case "text":
        baseColorTexture.setTexture(getCanvasTexture());
        break;
    }

  }

  function initializeModelViewer() {
    console.log("Initializing Model Viewer");

    modelViewer = document.getElementById('modelViewer');

    if (!modelViewer) {
      console.error("Model viewer element not found");
      return;
    }

    modelViewer.addEventListener("load", async () => {
      console.log("Model viewer loaded");
      const material = modelViewer.model.materials[0];
      const { baseColorTexture } = material.pbrMetallicRoughness;

      // Store the original texture
      originalTexture = baseColorTexture;

      // Initialize canvas texture
      canvasTexture = modelViewer.createCanvasTexture();

      // You might want to call an initial texture update here
      // updateCanvasTexture();
    });

    modelViewer.addEventListener("error", (error) => {
      console.error("Model viewer error:", error);
    });
  }

  
  // This function will attempt to initialize as soon as possible
  function tryInitialize() {
    if (document.readyState === 'loading') {
      // DOM not ready, add event listener
      document.addEventListener('DOMContentLoaded', initializeModelViewer);
    } else {
      // DOM is ready, call the function directly
      initializeModelViewer();
    }
  }

  // Call tryInitialize immediately
  tryInitialize();
</script>
