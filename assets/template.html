<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
    body,
    model-viewer {
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
    }
</style>
<script type="module" src="model-viewer.min.js" defer></script>
<!-- body -->

<script>
  let canvasTexture = null;
  let originalTexture = null; // Variable to store the original texture
  let modelViewer = null;
  
  let bgColorDefault = "#ffffff";
  let textColorDefault = "#000000";

  function getCanvasTexture() {
    if (canvasTexture) return canvasTexture;
    console.log("Creating new canvas texture");
    canvasTexture = modelViewer.createCanvasTexture();
    updateCanvasTexture();
    return canvasTexture;
  }

  function updateCanvasTexture1(
    customText,
    color,
    backgroundColor,
    fontSize,
    textX,
    textY,
    texture,
    rotation
  ) {
    const canvas = canvasTexture ? canvasTexture.source.element : document.createElement('canvas');
    const ctx = canvas.getContext('2d');

    ctx.fillStyle = backgroundColor || bgColorDefault;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    
    const modelInfo = analyzeModel();
    const suggestedSettings = suggestTextureSettings(modelInfo);

    console.log("Suggested settings:", suggestedSettings);

    // Only proceed with text rendering if customText is provided
    if (customText != null) {
      
      ctx.save();

      // Apply scaling
      ctx.scale(suggestedSettings.scaleX, suggestedSettings.scaleY);

      const baseFontSize = fontSize || 24;
      const adjustedFontSize = baseFontSize * (canvas.width / 512); // Scale font size based on canvas size
      ctx.font = `${adjustedFontSize}px Arial, sans-serif`;

      // Measure text dimensions
      const textMetrics = ctx.measureText(customText);
      const textWidth = textMetrics.width;
      const textHeight = adjustedFontSize; // Approximate height based on font size

      // Calculate the position where the text should be placed
      const posX = (textX != null ? textX : 0) * (canvas.width / 512);
      const posY = (textY != null ? textY : 0) * (canvas.height / 512);

      // Move to the desired position
      ctx.translate(
        posX + 35 * (canvas.width / 512) + textWidth / 2,
        posY + 86 * (canvas.height / 512)
      );

      //flip vertically 
      ctx.scale(1, -1);

      // Apply rotation
      ctx.rotate((rotation || 0) * Math.PI / 180);

      // Set text alignment and baseline
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      // Enable image smoothing
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = "high";


      // Set fill style
      ctx.fillStyle = color || textColorDefault;

      // Draw the text at (0, 0)
      ctx.fillText(customText, 0, 0);

      ctx.restore();


    }

    if (texture) updateTexture(texture);

    if (canvasTexture) {
      console.log("Updating canvas texture source 1");
      canvasTexture.source.update();
    }
  }

  function updateTexture(texture) {
    const material = modelViewer.model.materials[0];
    const { baseColorTexture } = material.pbrMetallicRoughness;

    // Store the original texture
    if (originalTexture === null) {
      console.log("keep original texture");
      originalTexture = baseColorTexture;
    }

    console.log("Texture type changed to:", texture);
    switch (texture) {
      case "none":
        baseColorTexture.setTexture(originalTexture);
        break;
      case "text":
        baseColorTexture.setTexture(getCanvasTexture());
        break;
    }

  }

  function initializeModelViewer() {
    console.log("Initializing Model Viewer");

    modelViewer = document.getElementById('modelViewer');

    if (!modelViewer) {
      console.error("Model viewer element not found");
      return;
    }

    // log device pixel ratio
    console.log("Device pixel ratio:", window.devicePixelRatio);

    modelViewer.addEventListener("load", async () => {
      console.log("Model viewer loaded");
      const material = modelViewer.model.materials[0];
      const { baseColorTexture } = material.pbrMetallicRoughness;

      // Store the original texture
      originalTexture = baseColorTexture;

      // Initialize canvas texture
      canvasTexture = modelViewer.createCanvasTexture();

      // Analyze the model after it's loaded
      analyzeModel();

      adjustCanvasResolution();
    });

    modelViewer.addEventListener("error", (error) => {
      console.error("Model viewer error:", error);
    });
  }

  // Function to adjust the canvas resolution dynamically
  function adjustCanvasResolution() {
    const canvas = canvasTexture.source.element;

    // Define a base size (e.g., 512x512)
    const baseSize = 512;

    // Get device pixel ratio
    const ratio = 3;

    // Optionally, get the original texture size
    const originalTextureWidth = originalTexture.texture.source.width;
    const originalTextureHeight = originalTexture.texture.source.height;

    // Set canvas dimensions
    // canvas.width = baseSize * ratio;
    // canvas.height = baseSize * ratio;

    // Limit canvas size to a maximum value to prevent performance issues
    const maxCanvasSize = 2048; // Adjust as needed
    canvas.width = 1024;
    canvas.height = 1024;

    // Scale the context
    const ctx = canvas.getContext("2d");
    ctx.scale(2, 2);

    console.log(`Canvas size set to ${canvas.width}x${canvas.height}`);
  }

  
  // This function will attempt to initialize as soon as possible
  function tryInitialize() {
    if (document.readyState === 'loading') {
      // DOM not ready, add event listener
      document.addEventListener('DOMContentLoaded', initializeModelViewer);
    } else {
      // DOM is ready, call the function directly
      initializeModelViewer();
    }
  }
  function analyzeModel() {
    if (!modelViewer || !modelViewer.model) {
      console.error("Model not loaded");
      return null;
    }

    const modelInfo = {
      dimensions: getModelDimensions(),
      materials: getModelMaterials(),
      uvBounds: getUVBounds()
    };

    console.log("Model analysis result:", modelInfo);
    suggestTextureSettings(modelInfo);
    return modelInfo;
  }

  function getModelDimensions() {
    const boundingBox = modelViewer.getBoundingBoxCenter();
    const size = modelViewer.getDimensions();
    return {
      width: size.x,
      height: size.y,
      depth: size.z,
      center: boundingBox
    };
  }

  function getModelMaterials() {
    const materials = [];
    if (modelViewer.model && modelViewer.model.materials) {
      modelViewer.model.materials.forEach((material, index) => {
        if (material.pbrMetallicRoughness && material.pbrMetallicRoughness.baseColorTexture) {
          const texture = material.pbrMetallicRoughness.baseColorTexture.texture;
          materials.push({
            name: material.name || `Material_${index}`,
            textureSize: {
              width: texture.source.width,
              height: texture.source.height
            }
          });
        }
      });
    }
    return materials;
  }

  function getUVBounds() {
    // const threeScene = modelViewer.scene;
    // const meshes = [];
    //
    // threeScene.traverse((child) => {
    //   if (child.isMesh) {
    //     meshes.push(child);
    //   }
    // });
    //
    // const mesh = meshes[0]; // Assuming the first mesh is the T-shirt
    // const uvAttribute = mesh.geometry.attributes.uv;
    //
    // if (uvAttribute) {
    //   const uvs = uvAttribute.array;
    //   let minU = Infinity, maxU = -Infinity, minV = Infinity, maxV = -Infinity;
    //
    //   for (let i = 0; i < uvs.length; i += 2) {
    //     const u = uvs[i];
    //     const v = uvs[i + 1];
    //
    //     minU = Math.min(minU, u);
    //     maxU = Math.max(maxU, u);
    //     minV = Math.min(minV, v);
    //     maxV = Math.max(maxV, v);
    //   }
    //
    //   return { minU, maxU, minV, maxV };
    // } else {
    //   console.warn("UV attributes not found");
    //   return null;
    // }
  }

  function suggestTextureSettings(modelInfo) {
    if (!modelInfo) return null;

    const materials = modelInfo.materials;
    const dimensions = modelInfo.dimensions;

    // Assuming the first material is the main texture
    const mainTexture = materials[0]?.textureSize;

    if (!mainTexture || !dimensions) {
      console.warn("Not enough information to suggest texture settings");
      return null;
    }

    // Since we don't have UV information, we'll make some assumptions
    // We'll assume the texture should be centered on the front face of the model
    const suggestedSettings = {
      offsetX: 0, // Centered horizontally
      offsetY: 0, // Centered vertically
      scaleX: 1,
      scaleY: 1,
      width: Math.min(mainTexture.width, dimensions.width),
      height: Math.min(mainTexture.height, dimensions.height)
    };

    console.log("Suggested texture settings:", suggestedSettings);
    return suggestedSettings;
  }

  // Call tryInitialize immediately
  tryInitialize();
</script>
