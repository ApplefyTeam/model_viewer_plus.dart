<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
    body,
    model-viewer {
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
    }
</style>
<script type="module" src="model-viewer.min.js" defer></script>
<!-- body -->

<script>
  let canvasTexture = null;
  let originalTexture = null; // Variable to store the original texture
  let modelViewer = null;
  
  let bgColorDefault = "#ffffff";
  let textColorDefault = "#000000";
  const defaultImageWidth = 100;
  const defaultImageHeight = 100;

  const canvasSize = 1024;
  const imageId = "image-print";

  function getCanvasTexture() {
    if (canvasTexture) return canvasTexture;
    console.log("Creating new canvas texture");
    canvasTexture = modelViewer.createCanvasTexture();
    updateCanvasTexture1();
    return canvasTexture;
  }

  function updateCanvasTexture1(
    customText,
    color,
    backgroundColor,
    fontSize,
    textX,
    textY,
    texture,
    rotation,
    imageSrc
  ) {
    const canvas = canvasTexture ? canvasTexture.source.element : document.createElement('canvas');
    const ctx = canvas.getContext('2d');

    ctx.fillStyle = backgroundColor || bgColorDefault;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    if (imageSrc) {
      console.log("Image source provided");
      const image = new Image(defaultImageWidth, defaultImageHeight);
      // set image id
      image.id = imageId;
      image.onload = function() {
        console.log("Image loaded");
        ctx.save();
        const dX = canvasSize / 2;
        const dY = canvasSize / 2;
        const startX = 100;
        const startY = 100;
        ctx.translate(
          60,
          96 * (canvas.height / 512)
        );
        // ctx.translate(dX, dY);
        ctx.scale(1, -1);
        ctx.drawImage(image, 0, 0, defaultImageWidth, defaultImageHeight);
        ctx.restore();

        if (customText != null) {
          drawText(canvas, customText, color, fontSize, textX, textY, rotation);
        }

        if (texture) updateTexture(texture);

        if (canvasTexture) {
          console.log("Updating canvas texture source 1");
          canvasTexture.source.update();
        }

      }
      image.onerror = function() {
        console.error("Image load error");
        if (customText != null) {
          drawText(canvas, customText, color, fontSize, textX, textY, rotation);
        }

        if (texture) updateTexture(texture);

        if (canvasTexture) {
          console.log("Updating canvas texture source 1");
          canvasTexture.source.update();
        }
      }
      image.src = imageSrc;
    } else {
      console.log("No image source provided");
      if (customText != null) {
        drawText(canvas, customText, color, fontSize, textX, textY, rotation);
      }

      if (texture) updateTexture(texture);

      if (canvasTexture) {
        console.log("Updating canvas texture source 1");
        canvasTexture.source.update();
      }
    }
  }

  function drawText(canvas, customText, color, fontSize, textX, textY, rotation) {
    const ctx = canvas.getContext('2d');

    ctx.save();

    const baseFontSize = fontSize || 24;
    const adjustedFontSize = baseFontSize * (canvas.width / 512); // Scale font size based on canvas size
    ctx.font = `${adjustedFontSize}px Arial, sans-serif`;

    // Measure text dimensions
    const textMetrics = ctx.measureText(customText);
    const textWidth = textMetrics.width;
    const textHeight = adjustedFontSize; // Approximate height based on font size

    // Calculate the position where the text should be placed
    const posX = (textX != null ? textX : 0) * (canvas.width / 512);
    const posY = (textY != null ? textY : 0) * (canvas.height / 512);

    // Move to the desired position
    ctx.translate(
      posX + 35 * (canvas.width / 512) + textWidth / 2,
      posY + 86 * (canvas.height / 512)
    );

    //flip vertically 
    ctx.scale(1, -1);

    // Apply rotation
    ctx.rotate((rotation || 0) * Math.PI / 180);

    // Set text alignment and baseline
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    // Enable image smoothing
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = "high";


    // Set fill style
    ctx.fillStyle = color || textColorDefault;

    // Draw the text at (0, 0)
    ctx.fillText(customText, 0, 0);

    ctx.restore();
  }

  function drawImage() {

  }

  function updateTexture(texture) {
    const material = modelViewer.model.materials[0];
    const { baseColorTexture } = material.pbrMetallicRoughness;

    // Store the original texture
    if (originalTexture === null) {
      console.log("keep original texture");
      originalTexture = baseColorTexture;
    }

    console.log("Texture type changed to:", texture);
    switch (texture) {
      case "none":
        baseColorTexture.setTexture(null);
        break;
      case "text":
        baseColorTexture.setTexture(getCanvasTexture());
        break;
    }

  }

  function initializeModelViewer() {
    console.log("Initializing Model Viewer");

    modelViewer = document.getElementById('modelViewer');

    if (!modelViewer) {
      console.error("Model viewer element not found");
      return;
    }

    // log device pixel ratio
    console.log("Device pixel ratio:", window.devicePixelRatio);

    modelViewer.addEventListener("load", async () => {
      console.log("Model viewer loaded");
      const material = modelViewer.model.materials[0];
      const { baseColorTexture } = material.pbrMetallicRoughness;

      // Store the original texture
      originalTexture = baseColorTexture;

      // Initialize canvas texture
      canvasTexture = modelViewer.createCanvasTexture();


      adjustCanvasResolution();
    });

    modelViewer.addEventListener("error", (error) => {
      console.error("Model viewer error:", error);
    });
  }

  // Function to adjust the canvas resolution dynamically
  function adjustCanvasResolution() {
    const canvas = canvasTexture.source.element;

    // Define a base size (e.g., 512x512)
    const baseSize = 512;

    // Get device pixel ratio
    const ratio = 3;

    // Optionally, get the original texture size
    const originalTextureWidth = originalTexture.texture.source.width;
    const originalTextureHeight = originalTexture.texture.source.height;

    // Set canvas dimensions
    // canvas.width = baseSize * ratio;
    // canvas.height = baseSize * ratio;

    // Limit canvas size to a maximum value to prevent performance issues
    const maxCanvasSize = 2048; // Adjust as needed
    canvas.width = canvasSize;
    canvas.height = canvasSize;

    // Scale the context
    const ctx = canvas.getContext("2d");
    ctx.scale(2, 2);

    console.log(`Canvas size set to ${canvas.width}x${canvas.height}`);
  }

  
  // This function will attempt to initialize as soon as possible
  function tryInitialize() {
    if (document.readyState === 'loading') {
      // DOM not ready, add event listener
      document.addEventListener('DOMContentLoaded', initializeModelViewer);
    } else {
      // DOM is ready, call the function directly
      initializeModelViewer();
    }
  }

  // Call tryInitialize immediately
  tryInitialize();
</script>
